syntax = "proto3";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.gostring_all) = true;
option (gogoproto.populate_all) = true;
option (gogoproto.equal_all) = true;
option (gogoproto.compare_all) = true;
option (gogoproto.testgen_all) = true;
option (gogoproto.benchgen_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;

// Zero-Stor Data Types

enum ObjectStatus {
    missing = 0 [(gogoproto.enumvalue_customname) = "ObjectStatusMissing"];
    ok = 1 [(gogoproto.enumvalue_customname) = "ObjectStatusOK"];
    corrupted = 2 [(gogoproto.enumvalue_customname) = "ObjectStatusCorrupted"];
}

// NamespaceManager allows you to retrieve information about a namespace.
//
// Metadata required (by the server)
// for all methods of the ObjectManager:
//
//     "authentication"
//     JWT token to proof you have sufficient permissions
//     to execute the given action within the given namespace.
//
//     "label"
//     Identifier of the namespace,
//     where the manage will be stored at,
//     or the existing object already lives at.
//
// This metadata cannot be enforced by this protobuf schema.
// However, not defining any of this metadata for any given method,
// will result in a GRPC error.
service NamespaceManager {
    // GetNamespace gets all available information about
    // a requested namespace. Most of the information returned,
    // is not stored in persistent memory,
    // and instead computed on the fly or available
    // from the in-memory cache.
    rpc GetNamespace (GetNamespaceRequest) returns (GetNamespaceResponse) {}
}

message GetNamespaceRequest {}
message GetNamespaceResponse {
    string label = 1;
    int64 readRequestPerHour = 2;
    int64 writeRequestPerHour = 3;
    int64 nrObjects = 4;
}

// ObjectManager allows you to Manage objects and get info about them.
//
// Metadata required (by the server)
// for all methods of the ObjectManager:
//
//     "authentication"
//     JWT token to proof you have sufficient permissions
//     to execute the given action within the given namespace.
//
//     "label"
//     Identifier of the namespace,
//     where the manage will be stored at,
//     or the existing object already lives at.
//
// This metadata cannot be enforced by this protobuf schema.
// However, not defining any of this metadata for any given method,
// will result in a GRPC error.
//
// All methods operate within a given namespace,
// identified by the label given as metadata.
// Meaning that for example the ExistObject might
// return false because that key doesn't exist within
// the specified namespace, even though it might exists
// within an other namespace.
service ObjectManager {
    // Set an object, either overwriting an existing key,
    // or creating a new one.
    rpc SetObject (SetObjectRequest) returns (SetObjectResponse) {}

    // Get an existing object, linked to a given key.
    rpc GetObject (GetObjectRequest) returns (GetObjectResponse) {}

    // DeleteObject deletes an object.
    // Deleting an non-existing object is considered valid.
    rpc DeleteObject (DeleteObjectRequest) returns (DeleteObjectResponse) {}

    // GetObjectStatus returns the status of an object,
    // indicating whether it's OK, missing or corrupt.
    rpc GetObjectStatus (GetObjectStatusRequest) returns (GetObjectStatusResponse) {}

    // ListObjectKeys lists the keys of
    // all stored objects within the namespace (identified by the given label).
    rpc ListObjectKeys (ListObjectKeysRequest) returns (stream ListObjectKeysResponse) {}
}

message SetObjectRequest {
    bytes key = 1;
    bytes data = 2;
}
message SetObjectResponse {}

message GetObjectRequest {
    bytes key = 1;
}
message GetObjectResponse {
    bytes data = 1;
}

message DeleteObjectRequest {
    bytes key = 1;
}
message DeleteObjectResponse {
}

message GetObjectStatusRequest {
    bytes key = 1;
}
message GetObjectStatusResponse {
    ObjectStatus status = 1;
}

message ListObjectKeysRequest {}
message ListObjectKeysResponse {
    bytes key = 1;
}
