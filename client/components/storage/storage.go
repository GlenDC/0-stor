package storage

import (
	"errors"
	"runtime"

	"github.com/zero-os/0-stor/client/datastor"
)

var (
	// DefaultJobCount is the default job count used if the API
	// was created with a job count of 0.
	DefaultJobCount = runtime.NumCPU() * 2
)

// TODO:
// Streamline the `metastor.Chunk` and `datastor.Object` names.

// Errors that can be returned by a storage.
var (
	ErrUnexpectedShardsCount = errors.New("unexpected shards count")
	ErrShardsUnavailable     = errors.New("(too many?) shards are unavailable")
	ErrNotSupported          = errors.New("method is not supported")
	ErrInvalidDataSize       = errors.New("returned object has invalid data size")
)

// ObjectStorage is used store an object on a given cluster.
type ObjectStorage interface {
	// Write an object to a storage,
	// returning the generated configuration used to store it.
	//
	// Remember to store this configuration,
	// as you'll need it in order to read the object back.
	Write(object datastor.Object) (ObjectConfig, error)

	// Read the object from a storage,
	// using the storage config generated while writing the object, previously.
	Read(cfg ObjectConfig) (datastor.Object, error)

	// Check if an object is in a valid condition.
	//
	// The fast parameter can be given in case you want to do a fast check only,
	// which means it will return as soon as the object is found to be in a valid condition,
	// ignoring the possibility that it could even be in excellent condition.
	//
	// An error can be returned in case the given config
	// is not compatible with the used storage.
	// Meaning the object cannot be read, written or repaired.
	Check(cfg ObjectConfig, fast bool) (ObjectCheckStatus, error)

	// Repair will try to repair an object, already stored within the Storage.
	// If the object could be repaired, the new StorageConfig will
	// indicate the current shards the object has been stored on.
	//
	// validShards and invalidShards are optional parameters and can be given
	// to the Storage, as to hint it which shards are known to be (in)valid,
	// the storage type is however free to ignore these should those not be needed.
	Repair(cfg ObjectConfig) (ObjectConfig, error)

	// Close the storage and all its resources,
	// making the storage invalid for use after this call.
	//
	// Using a storage after closing it results in undefined behavior,
	// and should never be done.
	Close() error
}

// ObjectConfig is a configuration type,
// generated by an ObjectStorage when writing an object to that storage.
// The callee can use this config at a later time in order to read the object once again.
type ObjectConfig struct {
	Key      []byte
	Shards   []string
	DataSize int
}

// ObjectCheckStatus is the status returned when checking the
// state of an object using the `(ObjectStorage).Check` method,
// and indicates whether an object can, should or shouldn't be repaired.
type ObjectCheckStatus uint8

const (
	// ObjectCheckStatusInvalid indicates that the object is invalid as it is,
	// and should be repaired if it is needed for usage.
	ObjectCheckStatusInvalid ObjectCheckStatus = iota

	// ObjectCheckStatusValid indicates that the object is valid,
	// but it can be repaired to bring it (back) to an optimal state.
	ObjectCheckStatusValid

	// ObjectCheckStatusOptimal indicates that an object is valid in the most optimal way,
	// and no further action (such as repairing) is needed in any way.
	//
	// Repairing an object in this state is basically a waste of resources.
	ObjectCheckStatusOptimal
)

// String implements Stringer.String
func (status ObjectCheckStatus) String() string {
	return objectCheckStatusStringMapping[status]
}

const objectCheckStatusString = "invalidoptimal"

var objectCheckStatusStringMapping = map[ObjectCheckStatus]string{
	ObjectCheckStatusInvalid: objectCheckStatusString[:7],
	ObjectCheckStatusValid:   objectCheckStatusString[2:7],
	ObjectCheckStatusOptimal: objectCheckStatusString[7:],
}
