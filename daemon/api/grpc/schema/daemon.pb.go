// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema/daemon.proto

/*
	Package proxy is a generated protocol buffer package.

	It is generated from these files:
		schema/daemon.proto

	It has these top-level messages:
		Permission
		CreateJWTRequest
		CreateJWTReply
		NamespaceRequest
		NamespaceReply
		EditPermissionRequest
		EditPermissionReply
		GetPermissionRequest
		GetPermissionReply
		Chunk
		Meta
		WriteRequest
		WriteReply
		WriteFileRequest
		WriteFileReply
		WriteStreamRequest
		WriteStreamReply
		ReadRequest
		ReadReply
		ReadFileRequest
		ReadFileReply
		ReadStreamRequest
		ReadStreamReply
		DeleteRequest
		DeleteReply
		WalkRequest
		WalkReply
		AppendReferenceListRequest
		RemoveReferenceListRequest
		AppendReferenceListReply
		RemoveReferenceListReply
		CheckRequest
		CheckReply
		RepairRequest
		RepairReply
*/
package proxy

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type CheckReply_Status int32

const (
	CheckReplyStatusInvalid CheckReply_Status = 0
	CheckReplyStatusValid   CheckReply_Status = 1
	CheckReplyStatusOptimal CheckReply_Status = 2
)

var CheckReply_Status_name = map[int32]string{
	0: "invalid",
	1: "valid",
	2: "optimal",
}
var CheckReply_Status_value = map[string]int32{
	"invalid": 0,
	"valid":   1,
	"optimal": 2,
}

func (CheckReply_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{32, 0} }

// IYO permission
type Permission struct {
	Write  bool `protobuf:"varint,1,opt,name=write,proto3" json:"write,omitempty"`
	Read   bool `protobuf:"varint,2,opt,name=read,proto3" json:"read,omitempty"`
	Delete bool `protobuf:"varint,3,opt,name=delete,proto3" json:"delete,omitempty"`
	Admin  bool `protobuf:"varint,4,opt,name=admin,proto3" json:"admin,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{0} }

func (m *Permission) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *Permission) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Permission) GetDelete() bool {
	if m != nil {
		return m.Delete
	}
	return false
}

func (m *Permission) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

type CreateJWTRequest struct {
	Namespace  string      `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Permission *Permission `protobuf:"bytes,2,opt,name=permission" json:"permission,omitempty"`
}

func (m *CreateJWTRequest) Reset()                    { *m = CreateJWTRequest{} }
func (*CreateJWTRequest) ProtoMessage()               {}
func (*CreateJWTRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{1} }

func (m *CreateJWTRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CreateJWTRequest) GetPermission() *Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

type CreateJWTReply struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *CreateJWTReply) Reset()                    { *m = CreateJWTReply{} }
func (*CreateJWTReply) ProtoMessage()               {}
func (*CreateJWTReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{2} }

func (m *CreateJWTReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type NamespaceRequest struct {
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *NamespaceRequest) Reset()                    { *m = NamespaceRequest{} }
func (*NamespaceRequest) ProtoMessage()               {}
func (*NamespaceRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{3} }

func (m *NamespaceRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type NamespaceReply struct {
}

func (m *NamespaceReply) Reset()                    { *m = NamespaceReply{} }
func (*NamespaceReply) ProtoMessage()               {}
func (*NamespaceReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{4} }

type EditPermissionRequest struct {
	Namespace  string      `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	UserID     string      `protobuf:"bytes,2,opt,name=userID,proto3" json:"userID,omitempty"`
	Permission *Permission `protobuf:"bytes,3,opt,name=permission" json:"permission,omitempty"`
}

func (m *EditPermissionRequest) Reset()                    { *m = EditPermissionRequest{} }
func (*EditPermissionRequest) ProtoMessage()               {}
func (*EditPermissionRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{5} }

func (m *EditPermissionRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *EditPermissionRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *EditPermissionRequest) GetPermission() *Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

type EditPermissionReply struct {
}

func (m *EditPermissionReply) Reset()                    { *m = EditPermissionReply{} }
func (*EditPermissionReply) ProtoMessage()               {}
func (*EditPermissionReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{6} }

type GetPermissionRequest struct {
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	UserID    string `protobuf:"bytes,2,opt,name=userID,proto3" json:"userID,omitempty"`
}

func (m *GetPermissionRequest) Reset()                    { *m = GetPermissionRequest{} }
func (*GetPermissionRequest) ProtoMessage()               {}
func (*GetPermissionRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{7} }

func (m *GetPermissionRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetPermissionRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type GetPermissionReply struct {
	Permission *Permission `protobuf:"bytes,1,opt,name=permission" json:"permission,omitempty"`
}

func (m *GetPermissionReply) Reset()                    { *m = GetPermissionReply{} }
func (*GetPermissionReply) ProtoMessage()               {}
func (*GetPermissionReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{8} }

func (m *GetPermissionReply) GetPermission() *Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

type Chunk struct {
	Size_  int64    `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Key    []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Shards []string `protobuf:"bytes,3,rep,name=shards" json:"shards,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{9} }

func (m *Chunk) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Chunk) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Chunk) GetShards() []string {
	if m != nil {
		return m.Shards
	}
	return nil
}

type Meta struct {
	Epoch    int64    `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Key      []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	EncrKey  []byte   `protobuf:"bytes,3,opt,name=encrKey,proto3" json:"encrKey,omitempty"`
	Chunks   []*Chunk `protobuf:"bytes,4,rep,name=chunks" json:"chunks,omitempty"`
	Previous []byte   `protobuf:"bytes,5,opt,name=previous,proto3" json:"previous,omitempty"`
	Next     []byte   `protobuf:"bytes,6,opt,name=next,proto3" json:"next,omitempty"`
}

func (m *Meta) Reset()                    { *m = Meta{} }
func (*Meta) ProtoMessage()               {}
func (*Meta) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{10} }

func (m *Meta) GetEpoch() int64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Meta) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Meta) GetEncrKey() []byte {
	if m != nil {
		return m.EncrKey
	}
	return nil
}

func (m *Meta) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *Meta) GetPrevious() []byte {
	if m != nil {
		return m.Previous
	}
	return nil
}

func (m *Meta) GetNext() []byte {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteRequest struct {
	Key           []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta          *Meta    `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	Value         []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ReferenceList []string `protobuf:"bytes,4,rep,name=referenceList" json:"referenceList,omitempty"`
	PrevKey       string   `protobuf:"bytes,5,opt,name=prevKey,proto3" json:"prevKey,omitempty"`
	PrevMeta      *Meta    `protobuf:"bytes,6,opt,name=prevMeta" json:"prevMeta,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{11} }

func (m *WriteRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *WriteRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WriteRequest) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

func (m *WriteRequest) GetPrevKey() string {
	if m != nil {
		return m.PrevKey
	}
	return ""
}

func (m *WriteRequest) GetPrevMeta() *Meta {
	if m != nil {
		return m.PrevMeta
	}
	return nil
}

type WriteReply struct {
	Meta *Meta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
}

func (m *WriteReply) Reset()                    { *m = WriteReply{} }
func (*WriteReply) ProtoMessage()               {}
func (*WriteReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{12} }

func (m *WriteReply) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type WriteFileRequest struct {
	Key           []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta          *Meta    `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	FilePath      string   `protobuf:"bytes,3,opt,name=filePath,proto3" json:"filePath,omitempty"`
	ReferenceList []string `protobuf:"bytes,4,rep,name=referenceList" json:"referenceList,omitempty"`
	PrevKey       string   `protobuf:"bytes,5,opt,name=prevKey,proto3" json:"prevKey,omitempty"`
	PrevMeta      *Meta    `protobuf:"bytes,6,opt,name=prevMeta" json:"prevMeta,omitempty"`
}

func (m *WriteFileRequest) Reset()                    { *m = WriteFileRequest{} }
func (*WriteFileRequest) ProtoMessage()               {}
func (*WriteFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{13} }

func (m *WriteFileRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteFileRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *WriteFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *WriteFileRequest) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

func (m *WriteFileRequest) GetPrevKey() string {
	if m != nil {
		return m.PrevKey
	}
	return ""
}

func (m *WriteFileRequest) GetPrevMeta() *Meta {
	if m != nil {
		return m.PrevMeta
	}
	return nil
}

type WriteFileReply struct {
	Meta *Meta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
}

func (m *WriteFileReply) Reset()                    { *m = WriteFileReply{} }
func (*WriteFileReply) ProtoMessage()               {}
func (*WriteFileReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{14} }

func (m *WriteFileReply) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type WriteStreamRequest struct {
	Key           []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta          *Meta    `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	Value         []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ReferenceList []string `protobuf:"bytes,4,rep,name=referenceList" json:"referenceList,omitempty"`
	PrevKey       []byte   `protobuf:"bytes,5,opt,name=prevKey,proto3" json:"prevKey,omitempty"`
	PrevMeta      *Meta    `protobuf:"bytes,6,opt,name=prevMeta" json:"prevMeta,omitempty"`
}

func (m *WriteStreamRequest) Reset()                    { *m = WriteStreamRequest{} }
func (*WriteStreamRequest) ProtoMessage()               {}
func (*WriteStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{15} }

func (m *WriteStreamRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteStreamRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *WriteStreamRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WriteStreamRequest) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

func (m *WriteStreamRequest) GetPrevKey() []byte {
	if m != nil {
		return m.PrevKey
	}
	return nil
}

func (m *WriteStreamRequest) GetPrevMeta() *Meta {
	if m != nil {
		return m.PrevMeta
	}
	return nil
}

type WriteStreamReply struct {
	Meta *Meta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
}

func (m *WriteStreamReply) Reset()                    { *m = WriteStreamReply{} }
func (*WriteStreamReply) ProtoMessage()               {}
func (*WriteStreamReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{16} }

func (m *WriteStreamReply) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type ReadRequest struct {
	Key  []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta *Meta  `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{17} }

func (m *ReadRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ReadRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type ReadReply struct {
	Value         []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	ReferenceList []string `protobuf:"bytes,2,rep,name=referenceList" json:"referenceList,omitempty"`
}

func (m *ReadReply) Reset()                    { *m = ReadReply{} }
func (*ReadReply) ProtoMessage()               {}
func (*ReadReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{18} }

func (m *ReadReply) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ReadReply) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

type ReadFileRequest struct {
	Key      []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	FilePath string `protobuf:"bytes,3,opt,name=filePath,proto3" json:"filePath,omitempty"`
}

func (m *ReadFileRequest) Reset()                    { *m = ReadFileRequest{} }
func (*ReadFileRequest) ProtoMessage()               {}
func (*ReadFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{19} }

func (m *ReadFileRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ReadFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

type ReadFileReply struct {
	ReferenceList []string `protobuf:"bytes,1,rep,name=referenceList" json:"referenceList,omitempty"`
}

func (m *ReadFileReply) Reset()                    { *m = ReadFileReply{} }
func (*ReadFileReply) ProtoMessage()               {}
func (*ReadFileReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{20} }

func (m *ReadFileReply) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

type ReadStreamRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ReadStreamRequest) Reset()                    { *m = ReadStreamRequest{} }
func (*ReadStreamRequest) ProtoMessage()               {}
func (*ReadStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{21} }

func (m *ReadStreamRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type ReadStreamReply struct {
	Value         []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	ReferenceList []string `protobuf:"bytes,2,rep,name=referenceList" json:"referenceList,omitempty"`
}

func (m *ReadStreamReply) Reset()                    { *m = ReadStreamReply{} }
func (*ReadStreamReply) ProtoMessage()               {}
func (*ReadStreamReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{22} }

func (m *ReadStreamReply) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ReadStreamReply) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

type DeleteRequest struct {
	Key  []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta *Meta  `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{23} }

func (m *DeleteRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DeleteRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type DeleteReply struct {
}

func (m *DeleteReply) Reset()                    { *m = DeleteReply{} }
func (*DeleteReply) ProtoMessage()               {}
func (*DeleteReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{24} }

type WalkRequest struct {
	StartKey  []byte `protobuf:"bytes,1,opt,name=startKey,proto3" json:"startKey,omitempty"`
	FromEpoch int64  `protobuf:"varint,2,opt,name=fromEpoch,proto3" json:"fromEpoch,omitempty"`
	ToEpoch   int64  `protobuf:"varint,3,opt,name=toEpoch,proto3" json:"toEpoch,omitempty"`
}

func (m *WalkRequest) Reset()                    { *m = WalkRequest{} }
func (*WalkRequest) ProtoMessage()               {}
func (*WalkRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{25} }

func (m *WalkRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *WalkRequest) GetFromEpoch() int64 {
	if m != nil {
		return m.FromEpoch
	}
	return 0
}

func (m *WalkRequest) GetToEpoch() int64 {
	if m != nil {
		return m.ToEpoch
	}
	return 0
}

type WalkReply struct {
	Key           []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta          *Meta    `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	Value         []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ReferenceList []string `protobuf:"bytes,4,rep,name=referenceList" json:"referenceList,omitempty"`
}

func (m *WalkReply) Reset()                    { *m = WalkReply{} }
func (*WalkReply) ProtoMessage()               {}
func (*WalkReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{26} }

func (m *WalkReply) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WalkReply) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *WalkReply) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WalkReply) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

type AppendReferenceListRequest struct {
	Key           []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta          *Meta    `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	ReferenceList []string `protobuf:"bytes,3,rep,name=referenceList" json:"referenceList,omitempty"`
}

func (m *AppendReferenceListRequest) Reset()      { *m = AppendReferenceListRequest{} }
func (*AppendReferenceListRequest) ProtoMessage() {}
func (*AppendReferenceListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorDaemon, []int{27}
}

func (m *AppendReferenceListRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AppendReferenceListRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AppendReferenceListRequest) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

type RemoveReferenceListRequest struct {
	Key           []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Meta          *Meta    `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	ReferenceList []string `protobuf:"bytes,3,rep,name=referenceList" json:"referenceList,omitempty"`
}

func (m *RemoveReferenceListRequest) Reset()      { *m = RemoveReferenceListRequest{} }
func (*RemoveReferenceListRequest) ProtoMessage() {}
func (*RemoveReferenceListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorDaemon, []int{28}
}

func (m *RemoveReferenceListRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RemoveReferenceListRequest) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RemoveReferenceListRequest) GetReferenceList() []string {
	if m != nil {
		return m.ReferenceList
	}
	return nil
}

type AppendReferenceListReply struct {
}

func (m *AppendReferenceListReply) Reset()                    { *m = AppendReferenceListReply{} }
func (*AppendReferenceListReply) ProtoMessage()               {}
func (*AppendReferenceListReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{29} }

type RemoveReferenceListReply struct {
}

func (m *RemoveReferenceListReply) Reset()                    { *m = RemoveReferenceListReply{} }
func (*RemoveReferenceListReply) ProtoMessage()               {}
func (*RemoveReferenceListReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{30} }

type CheckRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *CheckRequest) Reset()                    { *m = CheckRequest{} }
func (*CheckRequest) ProtoMessage()               {}
func (*CheckRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{31} }

func (m *CheckRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type CheckReply struct {
	Status CheckReply_Status `protobuf:"varint,1,opt,name=status,proto3,enum=proxy.CheckReply_Status" json:"status,omitempty"`
}

func (m *CheckReply) Reset()                    { *m = CheckReply{} }
func (*CheckReply) ProtoMessage()               {}
func (*CheckReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{32} }

func (m *CheckReply) GetStatus() CheckReply_Status {
	if m != nil {
		return m.Status
	}
	return CheckReplyStatusInvalid
}

type RepairRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *RepairRequest) Reset()                    { *m = RepairRequest{} }
func (*RepairRequest) ProtoMessage()               {}
func (*RepairRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{33} }

func (m *RepairRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type RepairReply struct {
}

func (m *RepairReply) Reset()                    { *m = RepairReply{} }
func (*RepairReply) ProtoMessage()               {}
func (*RepairReply) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{34} }

func init() {
	proto.RegisterType((*Permission)(nil), "proxy.Permission")
	proto.RegisterType((*CreateJWTRequest)(nil), "proxy.CreateJWTRequest")
	proto.RegisterType((*CreateJWTReply)(nil), "proxy.CreateJWTReply")
	proto.RegisterType((*NamespaceRequest)(nil), "proxy.NamespaceRequest")
	proto.RegisterType((*NamespaceReply)(nil), "proxy.NamespaceReply")
	proto.RegisterType((*EditPermissionRequest)(nil), "proxy.EditPermissionRequest")
	proto.RegisterType((*EditPermissionReply)(nil), "proxy.EditPermissionReply")
	proto.RegisterType((*GetPermissionRequest)(nil), "proxy.GetPermissionRequest")
	proto.RegisterType((*GetPermissionReply)(nil), "proxy.GetPermissionReply")
	proto.RegisterType((*Chunk)(nil), "proxy.Chunk")
	proto.RegisterType((*Meta)(nil), "proxy.Meta")
	proto.RegisterType((*WriteRequest)(nil), "proxy.WriteRequest")
	proto.RegisterType((*WriteReply)(nil), "proxy.WriteReply")
	proto.RegisterType((*WriteFileRequest)(nil), "proxy.WriteFileRequest")
	proto.RegisterType((*WriteFileReply)(nil), "proxy.WriteFileReply")
	proto.RegisterType((*WriteStreamRequest)(nil), "proxy.WriteStreamRequest")
	proto.RegisterType((*WriteStreamReply)(nil), "proxy.WriteStreamReply")
	proto.RegisterType((*ReadRequest)(nil), "proxy.ReadRequest")
	proto.RegisterType((*ReadReply)(nil), "proxy.ReadReply")
	proto.RegisterType((*ReadFileRequest)(nil), "proxy.ReadFileRequest")
	proto.RegisterType((*ReadFileReply)(nil), "proxy.ReadFileReply")
	proto.RegisterType((*ReadStreamRequest)(nil), "proxy.ReadStreamRequest")
	proto.RegisterType((*ReadStreamReply)(nil), "proxy.ReadStreamReply")
	proto.RegisterType((*DeleteRequest)(nil), "proxy.DeleteRequest")
	proto.RegisterType((*DeleteReply)(nil), "proxy.DeleteReply")
	proto.RegisterType((*WalkRequest)(nil), "proxy.WalkRequest")
	proto.RegisterType((*WalkReply)(nil), "proxy.WalkReply")
	proto.RegisterType((*AppendReferenceListRequest)(nil), "proxy.AppendReferenceListRequest")
	proto.RegisterType((*RemoveReferenceListRequest)(nil), "proxy.RemoveReferenceListRequest")
	proto.RegisterType((*AppendReferenceListReply)(nil), "proxy.AppendReferenceListReply")
	proto.RegisterType((*RemoveReferenceListReply)(nil), "proxy.RemoveReferenceListReply")
	proto.RegisterType((*CheckRequest)(nil), "proxy.CheckRequest")
	proto.RegisterType((*CheckReply)(nil), "proxy.CheckReply")
	proto.RegisterType((*RepairRequest)(nil), "proxy.RepairRequest")
	proto.RegisterType((*RepairReply)(nil), "proxy.RepairReply")
	proto.RegisterEnum("proxy.CheckReply_Status", CheckReply_Status_name, CheckReply_Status_value)
}
func (x CheckReply_Status) String() string {
	s, ok := CheckReply_Status_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Permission) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Permission)
	if !ok {
		that2, ok := that.(Permission)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Write != that1.Write {
		return false
	}
	if this.Read != that1.Read {
		return false
	}
	if this.Delete != that1.Delete {
		return false
	}
	if this.Admin != that1.Admin {
		return false
	}
	return true
}
func (this *CreateJWTRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateJWTRequest)
	if !ok {
		that2, ok := that.(CreateJWTRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if !this.Permission.Equal(that1.Permission) {
		return false
	}
	return true
}
func (this *CreateJWTReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateJWTReply)
	if !ok {
		that2, ok := that.(CreateJWTReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *NamespaceRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRequest)
	if !ok {
		that2, ok := that.(NamespaceRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *NamespaceReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceReply)
	if !ok {
		that2, ok := that.(NamespaceReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *EditPermissionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EditPermissionRequest)
	if !ok {
		that2, ok := that.(EditPermissionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	if !this.Permission.Equal(that1.Permission) {
		return false
	}
	return true
}
func (this *EditPermissionReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EditPermissionReply)
	if !ok {
		that2, ok := that.(EditPermissionReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetPermissionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetPermissionRequest)
	if !ok {
		that2, ok := that.(GetPermissionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	return true
}
func (this *GetPermissionReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetPermissionReply)
	if !ok {
		that2, ok := that.(GetPermissionReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Permission.Equal(that1.Permission) {
		return false
	}
	return true
}
func (this *Chunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Chunk)
	if !ok {
		that2, ok := that.(Chunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if len(this.Shards) != len(that1.Shards) {
		return false
	}
	for i := range this.Shards {
		if this.Shards[i] != that1.Shards[i] {
			return false
		}
	}
	return true
}
func (this *Meta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Meta)
	if !ok {
		that2, ok := that.(Meta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.EncrKey, that1.EncrKey) {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Previous, that1.Previous) {
		return false
	}
	if !bytes.Equal(this.Next, that1.Next) {
		return false
	}
	return true
}
func (this *WriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteRequest)
	if !ok {
		that2, ok := that.(WriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	if this.PrevKey != that1.PrevKey {
		return false
	}
	if !this.PrevMeta.Equal(that1.PrevMeta) {
		return false
	}
	return true
}
func (this *WriteReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteReply)
	if !ok {
		that2, ok := that.(WriteReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	return true
}
func (this *WriteFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteFileRequest)
	if !ok {
		that2, ok := that.(WriteFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	if this.PrevKey != that1.PrevKey {
		return false
	}
	if !this.PrevMeta.Equal(that1.PrevMeta) {
		return false
	}
	return true
}
func (this *WriteFileReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteFileReply)
	if !ok {
		that2, ok := that.(WriteFileReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	return true
}
func (this *WriteStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest)
	if !ok {
		that2, ok := that.(WriteStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	if !bytes.Equal(this.PrevKey, that1.PrevKey) {
		return false
	}
	if !this.PrevMeta.Equal(that1.PrevMeta) {
		return false
	}
	return true
}
func (this *WriteStreamReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamReply)
	if !ok {
		that2, ok := that.(WriteStreamReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	return true
}
func (this *ReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	return true
}
func (this *ReadReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadReply)
	if !ok {
		that2, ok := that.(ReadReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	return true
}
func (this *ReadFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest)
	if !ok {
		that2, ok := that.(ReadFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	return true
}
func (this *ReadFileReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileReply)
	if !ok {
		that2, ok := that.(ReadFileReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	return true
}
func (this *ReadStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest)
	if !ok {
		that2, ok := that.(ReadStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadStreamReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamReply)
	if !ok {
		that2, ok := that.(ReadStreamReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	return true
}
func (this *DeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest)
	if !ok {
		that2, ok := that.(DeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	return true
}
func (this *DeleteReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteReply)
	if !ok {
		that2, ok := that.(DeleteReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *WalkRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WalkRequest)
	if !ok {
		that2, ok := that.(WalkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.StartKey, that1.StartKey) {
		return false
	}
	if this.FromEpoch != that1.FromEpoch {
		return false
	}
	if this.ToEpoch != that1.ToEpoch {
		return false
	}
	return true
}
func (this *WalkReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WalkReply)
	if !ok {
		that2, ok := that.(WalkReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	return true
}
func (this *AppendReferenceListRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppendReferenceListRequest)
	if !ok {
		that2, ok := that.(AppendReferenceListRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	return true
}
func (this *RemoveReferenceListRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveReferenceListRequest)
	if !ok {
		that2, ok := that.(RemoveReferenceListRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if len(this.ReferenceList) != len(that1.ReferenceList) {
		return false
	}
	for i := range this.ReferenceList {
		if this.ReferenceList[i] != that1.ReferenceList[i] {
			return false
		}
	}
	return true
}
func (this *AppendReferenceListReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppendReferenceListReply)
	if !ok {
		that2, ok := that.(AppendReferenceListReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *RemoveReferenceListReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveReferenceListReply)
	if !ok {
		that2, ok := that.(RemoveReferenceListReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest)
	if !ok {
		that2, ok := that.(CheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *CheckReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckReply)
	if !ok {
		that2, ok := that.(CheckReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *RepairRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepairRequest)
	if !ok {
		that2, ok := that.(RepairRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *RepairReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepairReply)
	if !ok {
		that2, ok := that.(RepairReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Permission) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proxy.Permission{")
	s = append(s, "Write: "+fmt.Sprintf("%#v", this.Write)+",\n")
	s = append(s, "Read: "+fmt.Sprintf("%#v", this.Read)+",\n")
	s = append(s, "Delete: "+fmt.Sprintf("%#v", this.Delete)+",\n")
	s = append(s, "Admin: "+fmt.Sprintf("%#v", this.Admin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateJWTRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.CreateJWTRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.Permission != nil {
		s = append(s, "Permission: "+fmt.Sprintf("%#v", this.Permission)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateJWTReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.CreateJWTReply{")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.NamespaceRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proxy.NamespaceReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditPermissionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proxy.EditPermissionRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	if this.Permission != nil {
		s = append(s, "Permission: "+fmt.Sprintf("%#v", this.Permission)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditPermissionReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proxy.EditPermissionReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPermissionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.GetPermissionRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPermissionReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.GetPermissionReply{")
	if this.Permission != nil {
		s = append(s, "Permission: "+fmt.Sprintf("%#v", this.Permission)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Chunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proxy.Chunk{")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Shards: "+fmt.Sprintf("%#v", this.Shards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Meta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proxy.Meta{")
	s = append(s, "Epoch: "+fmt.Sprintf("%#v", this.Epoch)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "EncrKey: "+fmt.Sprintf("%#v", this.EncrKey)+",\n")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "Previous: "+fmt.Sprintf("%#v", this.Previous)+",\n")
	s = append(s, "Next: "+fmt.Sprintf("%#v", this.Next)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proxy.WriteRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "PrevKey: "+fmt.Sprintf("%#v", this.PrevKey)+",\n")
	if this.PrevMeta != nil {
		s = append(s, "PrevMeta: "+fmt.Sprintf("%#v", this.PrevMeta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.WriteReply{")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proxy.WriteFileRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "PrevKey: "+fmt.Sprintf("%#v", this.PrevKey)+",\n")
	if this.PrevMeta != nil {
		s = append(s, "PrevMeta: "+fmt.Sprintf("%#v", this.PrevMeta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteFileReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.WriteFileReply{")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proxy.WriteStreamRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "PrevKey: "+fmt.Sprintf("%#v", this.PrevKey)+",\n")
	if this.PrevMeta != nil {
		s = append(s, "PrevMeta: "+fmt.Sprintf("%#v", this.PrevMeta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.WriteStreamReply{")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.ReadRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.ReadReply{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.ReadFileRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadFileReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.ReadFileReply{")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.ReadStreamRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadStreamReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.ReadStreamReply{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proxy.DeleteRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proxy.DeleteReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WalkRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proxy.WalkRequest{")
	s = append(s, "StartKey: "+fmt.Sprintf("%#v", this.StartKey)+",\n")
	s = append(s, "FromEpoch: "+fmt.Sprintf("%#v", this.FromEpoch)+",\n")
	s = append(s, "ToEpoch: "+fmt.Sprintf("%#v", this.ToEpoch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WalkReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proxy.WalkReply{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppendReferenceListRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proxy.AppendReferenceListRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoveReferenceListRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proxy.RemoveReferenceListRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "ReferenceList: "+fmt.Sprintf("%#v", this.ReferenceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppendReferenceListReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proxy.AppendReferenceListReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoveReferenceListReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proxy.RemoveReferenceListReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.CheckRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.CheckReply{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepairRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proxy.RepairRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepairReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proxy.RepairReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDaemon(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NamespaceService service

type NamespaceServiceClient interface {
	CreateJWT(ctx context.Context, in *CreateJWTRequest, opts ...grpc.CallOption) (*CreateJWTReply, error)
	CreateNamespace(ctx context.Context, in *NamespaceRequest, opts ...grpc.CallOption) (*NamespaceReply, error)
	DeleteNamespace(ctx context.Context, in *NamespaceRequest, opts ...grpc.CallOption) (*NamespaceReply, error)
	GivePermission(ctx context.Context, in *EditPermissionRequest, opts ...grpc.CallOption) (*EditPermissionReply, error)
	RemovePermission(ctx context.Context, in *EditPermissionRequest, opts ...grpc.CallOption) (*EditPermissionReply, error)
	GetPermission(ctx context.Context, in *GetPermissionRequest, opts ...grpc.CallOption) (*GetPermissionReply, error)
}

type namespaceServiceClient struct {
	cc *grpc.ClientConn
}

func NewNamespaceServiceClient(cc *grpc.ClientConn) NamespaceServiceClient {
	return &namespaceServiceClient{cc}
}

func (c *namespaceServiceClient) CreateJWT(ctx context.Context, in *CreateJWTRequest, opts ...grpc.CallOption) (*CreateJWTReply, error) {
	out := new(CreateJWTReply)
	err := grpc.Invoke(ctx, "/proxy.NamespaceService/CreateJWT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespaceServiceClient) CreateNamespace(ctx context.Context, in *NamespaceRequest, opts ...grpc.CallOption) (*NamespaceReply, error) {
	out := new(NamespaceReply)
	err := grpc.Invoke(ctx, "/proxy.NamespaceService/CreateNamespace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespaceServiceClient) DeleteNamespace(ctx context.Context, in *NamespaceRequest, opts ...grpc.CallOption) (*NamespaceReply, error) {
	out := new(NamespaceReply)
	err := grpc.Invoke(ctx, "/proxy.NamespaceService/DeleteNamespace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespaceServiceClient) GivePermission(ctx context.Context, in *EditPermissionRequest, opts ...grpc.CallOption) (*EditPermissionReply, error) {
	out := new(EditPermissionReply)
	err := grpc.Invoke(ctx, "/proxy.NamespaceService/GivePermission", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespaceServiceClient) RemovePermission(ctx context.Context, in *EditPermissionRequest, opts ...grpc.CallOption) (*EditPermissionReply, error) {
	out := new(EditPermissionReply)
	err := grpc.Invoke(ctx, "/proxy.NamespaceService/RemovePermission", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespaceServiceClient) GetPermission(ctx context.Context, in *GetPermissionRequest, opts ...grpc.CallOption) (*GetPermissionReply, error) {
	out := new(GetPermissionReply)
	err := grpc.Invoke(ctx, "/proxy.NamespaceService/GetPermission", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NamespaceService service

type NamespaceServiceServer interface {
	CreateJWT(context.Context, *CreateJWTRequest) (*CreateJWTReply, error)
	CreateNamespace(context.Context, *NamespaceRequest) (*NamespaceReply, error)
	DeleteNamespace(context.Context, *NamespaceRequest) (*NamespaceReply, error)
	GivePermission(context.Context, *EditPermissionRequest) (*EditPermissionReply, error)
	RemovePermission(context.Context, *EditPermissionRequest) (*EditPermissionReply, error)
	GetPermission(context.Context, *GetPermissionRequest) (*GetPermissionReply, error)
}

func RegisterNamespaceServiceServer(s *grpc.Server, srv NamespaceServiceServer) {
	s.RegisterService(&_NamespaceService_serviceDesc, srv)
}

func _NamespaceService_CreateJWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJWTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespaceServiceServer).CreateJWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.NamespaceService/CreateJWT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespaceServiceServer).CreateJWT(ctx, req.(*CreateJWTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespaceService_CreateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespaceServiceServer).CreateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.NamespaceService/CreateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespaceServiceServer).CreateNamespace(ctx, req.(*NamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespaceService_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespaceServiceServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.NamespaceService/DeleteNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespaceServiceServer).DeleteNamespace(ctx, req.(*NamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespaceService_GivePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespaceServiceServer).GivePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.NamespaceService/GivePermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespaceServiceServer).GivePermission(ctx, req.(*EditPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespaceService_RemovePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespaceServiceServer).RemovePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.NamespaceService/RemovePermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespaceServiceServer).RemovePermission(ctx, req.(*EditPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespaceService_GetPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespaceServiceServer).GetPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.NamespaceService/GetPermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespaceServiceServer).GetPermission(ctx, req.(*GetPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NamespaceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proxy.NamespaceService",
	HandlerType: (*NamespaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJWT",
			Handler:    _NamespaceService_CreateJWT_Handler,
		},
		{
			MethodName: "CreateNamespace",
			Handler:    _NamespaceService_CreateNamespace_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _NamespaceService_DeleteNamespace_Handler,
		},
		{
			MethodName: "GivePermission",
			Handler:    _NamespaceService_GivePermission_Handler,
		},
		{
			MethodName: "RemovePermission",
			Handler:    _NamespaceService_RemovePermission_Handler,
		},
		{
			MethodName: "GetPermission",
			Handler:    _NamespaceService_GetPermission_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "schema/daemon.proto",
}

// Client API for ObjectService service

type ObjectServiceClient interface {
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteReply, error)
	WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileReply, error)
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (ObjectService_WriteStreamClient, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadReply, error)
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileReply, error)
	ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (ObjectService_ReadStreamClient, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteReply, error)
	Walk(ctx context.Context, in *WalkRequest, opts ...grpc.CallOption) (ObjectService_WalkClient, error)
	AppendReferenceList(ctx context.Context, in *AppendReferenceListRequest, opts ...grpc.CallOption) (*AppendReferenceListReply, error)
	RemoveReferenceList(ctx context.Context, in *RemoveReferenceListRequest, opts ...grpc.CallOption) (*RemoveReferenceListReply, error)
	Check(ctx context.Context, in *CheckRequest, opts ...grpc.CallOption) (*CheckReply, error)
	Repair(ctx context.Context, in *RepairRequest, opts ...grpc.CallOption) (*RepairReply, error)
}

type objectServiceClient struct {
	cc *grpc.ClientConn
}

func NewObjectServiceClient(cc *grpc.ClientConn) ObjectServiceClient {
	return &objectServiceClient{cc}
}

func (c *objectServiceClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteReply, error) {
	out := new(WriteReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileReply, error) {
	out := new(WriteFileReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/WriteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (ObjectService_WriteStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectService_serviceDesc.Streams[0], c.cc, "/proxy.ObjectService/WriteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectServiceWriteStreamClient{stream}
	return x, nil
}

type ObjectService_WriteStreamClient interface {
	Send(*WriteStreamRequest) error
	CloseAndRecv() (*WriteStreamReply, error)
	grpc.ClientStream
}

type objectServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *objectServiceWriteStreamClient) Send(m *WriteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectServiceWriteStreamClient) CloseAndRecv() (*WriteStreamReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectServiceClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadReply, error) {
	out := new(ReadReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileReply, error) {
	out := new(ReadFileReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/ReadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (ObjectService_ReadStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectService_serviceDesc.Streams[1], c.cc, "/proxy.ObjectService/ReadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectService_ReadStreamClient interface {
	Recv() (*ReadStreamReply, error)
	grpc.ClientStream
}

type objectServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *objectServiceReadStreamClient) Recv() (*ReadStreamReply, error) {
	m := new(ReadStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteReply, error) {
	out := new(DeleteReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) Walk(ctx context.Context, in *WalkRequest, opts ...grpc.CallOption) (ObjectService_WalkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectService_serviceDesc.Streams[2], c.cc, "/proxy.ObjectService/Walk", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectServiceWalkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectService_WalkClient interface {
	Recv() (*WalkReply, error)
	grpc.ClientStream
}

type objectServiceWalkClient struct {
	grpc.ClientStream
}

func (x *objectServiceWalkClient) Recv() (*WalkReply, error) {
	m := new(WalkReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectServiceClient) AppendReferenceList(ctx context.Context, in *AppendReferenceListRequest, opts ...grpc.CallOption) (*AppendReferenceListReply, error) {
	out := new(AppendReferenceListReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/AppendReferenceList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) RemoveReferenceList(ctx context.Context, in *RemoveReferenceListRequest, opts ...grpc.CallOption) (*RemoveReferenceListReply, error) {
	out := new(RemoveReferenceListReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/RemoveReferenceList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) Check(ctx context.Context, in *CheckRequest, opts ...grpc.CallOption) (*CheckReply, error) {
	out := new(CheckReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/Check", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) Repair(ctx context.Context, in *RepairRequest, opts ...grpc.CallOption) (*RepairReply, error) {
	out := new(RepairReply)
	err := grpc.Invoke(ctx, "/proxy.ObjectService/Repair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ObjectService service

type ObjectServiceServer interface {
	Write(context.Context, *WriteRequest) (*WriteReply, error)
	WriteFile(context.Context, *WriteFileRequest) (*WriteFileReply, error)
	WriteStream(ObjectService_WriteStreamServer) error
	Read(context.Context, *ReadRequest) (*ReadReply, error)
	ReadFile(context.Context, *ReadFileRequest) (*ReadFileReply, error)
	ReadStream(*ReadStreamRequest, ObjectService_ReadStreamServer) error
	Delete(context.Context, *DeleteRequest) (*DeleteReply, error)
	Walk(*WalkRequest, ObjectService_WalkServer) error
	AppendReferenceList(context.Context, *AppendReferenceListRequest) (*AppendReferenceListReply, error)
	RemoveReferenceList(context.Context, *RemoveReferenceListRequest) (*RemoveReferenceListReply, error)
	Check(context.Context, *CheckRequest) (*CheckReply, error)
	Repair(context.Context, *RepairRequest) (*RepairReply, error)
}

func RegisterObjectServiceServer(s *grpc.Server, srv ObjectServiceServer) {
	s.RegisterService(&_ObjectService_serviceDesc, srv)
}

func _ObjectService_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/WriteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).WriteFile(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectServiceServer).WriteStream(&objectServiceWriteStreamServer{stream})
}

type ObjectService_WriteStreamServer interface {
	SendAndClose(*WriteStreamReply) error
	Recv() (*WriteStreamRequest, error)
	grpc.ServerStream
}

type objectServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *objectServiceWriteStreamServer) SendAndClose(m *WriteStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectServiceWriteStreamServer) Recv() (*WriteStreamRequest, error) {
	m := new(WriteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/ReadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).ReadFile(ctx, req.(*ReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectServiceServer).ReadStream(m, &objectServiceReadStreamServer{stream})
}

type ObjectService_ReadStreamServer interface {
	Send(*ReadStreamReply) error
	grpc.ServerStream
}

type objectServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *objectServiceReadStreamServer) Send(m *ReadStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_Walk_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WalkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectServiceServer).Walk(m, &objectServiceWalkServer{stream})
}

type ObjectService_WalkServer interface {
	Send(*WalkReply) error
	grpc.ServerStream
}

type objectServiceWalkServer struct {
	grpc.ServerStream
}

func (x *objectServiceWalkServer) Send(m *WalkReply) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectService_AppendReferenceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendReferenceListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).AppendReferenceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/AppendReferenceList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).AppendReferenceList(ctx, req.(*AppendReferenceListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_RemoveReferenceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveReferenceListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).RemoveReferenceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/RemoveReferenceList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).RemoveReferenceList(ctx, req.(*RemoveReferenceListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).Check(ctx, req.(*CheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_Repair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).Repair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proxy.ObjectService/Repair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).Repair(ctx, req.(*RepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ObjectService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proxy.ObjectService",
	HandlerType: (*ObjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _ObjectService_Write_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _ObjectService_WriteFile_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _ObjectService_Read_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _ObjectService_ReadFile_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ObjectService_Delete_Handler,
		},
		{
			MethodName: "AppendReferenceList",
			Handler:    _ObjectService_AppendReferenceList_Handler,
		},
		{
			MethodName: "RemoveReferenceList",
			Handler:    _ObjectService_RemoveReferenceList_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _ObjectService_Check_Handler,
		},
		{
			MethodName: "Repair",
			Handler:    _ObjectService_Repair_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteStream",
			Handler:       _ObjectService_WriteStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadStream",
			Handler:       _ObjectService_ReadStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Walk",
			Handler:       _ObjectService_Walk_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

func (m *Permission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Permission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Write {
		dAtA[i] = 0x8
		i++
		if m.Write {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Read {
		dAtA[i] = 0x10
		i++
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Delete {
		dAtA[i] = 0x18
		i++
		if m.Delete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Admin {
		dAtA[i] = 0x20
		i++
		if m.Admin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateJWTRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJWTRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Permission != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Permission.Size()))
		n1, err := m.Permission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CreateJWTReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJWTReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *NamespaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *NamespaceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EditPermissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditPermissionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.UserID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.UserID)))
		i += copy(dAtA[i:], m.UserID)
	}
	if m.Permission != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Permission.Size()))
		n2, err := m.Permission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *EditPermissionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditPermissionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetPermissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPermissionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.UserID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.UserID)))
		i += copy(dAtA[i:], m.UserID)
	}
	return i, nil
}

func (m *GetPermissionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPermissionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Permission != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Permission.Size()))
		n3, err := m.Permission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Size_))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Meta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.EncrKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.EncrKey)))
		i += copy(dAtA[i:], m.EncrKey)
	}
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Previous) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Previous)))
		i += copy(dAtA[i:], m.Previous)
	}
	if len(m.Next) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Next)))
		i += copy(dAtA[i:], m.Next)
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n4, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PrevKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.PrevKey)))
		i += copy(dAtA[i:], m.PrevKey)
	}
	if m.PrevMeta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.PrevMeta.Size()))
		n5, err := m.PrevMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *WriteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n6, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *WriteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n7, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PrevKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.PrevKey)))
		i += copy(dAtA[i:], m.PrevKey)
	}
	if m.PrevMeta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.PrevMeta.Size()))
		n8, err := m.PrevMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *WriteFileReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteFileReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n9, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *WriteStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n10, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PrevKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.PrevKey)))
		i += copy(dAtA[i:], m.PrevKey)
	}
	if m.PrevMeta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.PrevMeta.Size()))
		n11, err := m.PrevMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *WriteStreamReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n12, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n13, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ReadReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ReadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	return i, nil
}

func (m *ReadFileReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFileReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ReadStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *ReadStreamReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadStreamReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n14, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *DeleteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WalkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalkRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if m.FromEpoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.FromEpoch))
	}
	if m.ToEpoch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.ToEpoch))
	}
	return i, nil
}

func (m *WalkReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalkReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n15, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AppendReferenceListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReferenceListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n16, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *RemoveReferenceListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveReferenceListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Meta.Size()))
		n17, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AppendReferenceListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReferenceListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RemoveReferenceListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveReferenceListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *CheckReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *RepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *RepairReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintDaemon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Permission) Size() (n int) {
	var l int
	_ = l
	if m.Write {
		n += 2
	}
	if m.Read {
		n += 2
	}
	if m.Delete {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *CreateJWTRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Permission != nil {
		l = m.Permission.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *CreateJWTReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *NamespaceRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *NamespaceReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EditPermissionRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Permission != nil {
		l = m.Permission.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *EditPermissionReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetPermissionRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *GetPermissionReply) Size() (n int) {
	var l int
	_ = l
	if m.Permission != nil {
		l = m.Permission.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovDaemon(uint64(m.Size_))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *Meta) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovDaemon(uint64(m.Epoch))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.EncrKey)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.Previous)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Next)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.PrevKey)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.PrevMeta != nil {
		l = m.PrevMeta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteReply) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteFileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.PrevKey)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.PrevMeta != nil {
		l = m.PrevMeta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteFileReply) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.PrevKey)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.PrevMeta != nil {
		l = m.PrevMeta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamReply) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *ReadFileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadFileReply) Size() (n int) {
	var l int
	_ = l
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *ReadStreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadStreamReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WalkRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.FromEpoch != 0 {
		n += 1 + sovDaemon(uint64(m.FromEpoch))
	}
	if m.ToEpoch != 0 {
		n += 1 + sovDaemon(uint64(m.ToEpoch))
	}
	return n
}

func (m *WalkReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *AppendReferenceListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *RemoveReferenceListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.ReferenceList) > 0 {
		for _, s := range m.ReferenceList {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *AppendReferenceListReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RemoveReferenceListReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CheckRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *CheckReply) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDaemon(uint64(m.Status))
	}
	return n
}

func (m *RepairRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *RepairReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovDaemon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDaemon(x uint64) (n int) {
	return sovDaemon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Permission) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Permission{`,
		`Write:` + fmt.Sprintf("%v", this.Write) + `,`,
		`Read:` + fmt.Sprintf("%v", this.Read) + `,`,
		`Delete:` + fmt.Sprintf("%v", this.Delete) + `,`,
		`Admin:` + fmt.Sprintf("%v", this.Admin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateJWTRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateJWTRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Permission:` + strings.Replace(fmt.Sprintf("%v", this.Permission), "Permission", "Permission", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateJWTReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateJWTReply{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceReply{`,
		`}`,
	}, "")
	return s
}
func (this *EditPermissionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EditPermissionRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`UserID:` + fmt.Sprintf("%v", this.UserID) + `,`,
		`Permission:` + strings.Replace(fmt.Sprintf("%v", this.Permission), "Permission", "Permission", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EditPermissionReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EditPermissionReply{`,
		`}`,
	}, "")
	return s
}
func (this *GetPermissionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPermissionRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`UserID:` + fmt.Sprintf("%v", this.UserID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPermissionReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPermissionReply{`,
		`Permission:` + strings.Replace(fmt.Sprintf("%v", this.Permission), "Permission", "Permission", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Chunk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Chunk{`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Shards:` + fmt.Sprintf("%v", this.Shards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Meta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Meta{`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`EncrKey:` + fmt.Sprintf("%v", this.EncrKey) + `,`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`Previous:` + fmt.Sprintf("%v", this.Previous) + `,`,
		`Next:` + fmt.Sprintf("%v", this.Next) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`PrevKey:` + fmt.Sprintf("%v", this.PrevKey) + `,`,
		`PrevMeta:` + strings.Replace(fmt.Sprintf("%v", this.PrevMeta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteReply{`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteFileRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`PrevKey:` + fmt.Sprintf("%v", this.PrevKey) + `,`,
		`PrevMeta:` + strings.Replace(fmt.Sprintf("%v", this.PrevMeta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteFileReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteFileReply{`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`PrevKey:` + fmt.Sprintf("%v", this.PrevKey) + `,`,
		`PrevMeta:` + strings.Replace(fmt.Sprintf("%v", this.PrevMeta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamReply{`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadReply{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileReply{`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamReply{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteReply{`,
		`}`,
	}, "")
	return s
}
func (this *WalkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WalkRequest{`,
		`StartKey:` + fmt.Sprintf("%v", this.StartKey) + `,`,
		`FromEpoch:` + fmt.Sprintf("%v", this.FromEpoch) + `,`,
		`ToEpoch:` + fmt.Sprintf("%v", this.ToEpoch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WalkReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WalkReply{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppendReferenceListRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppendReferenceListRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoveReferenceListRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoveReferenceListRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`ReferenceList:` + fmt.Sprintf("%v", this.ReferenceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppendReferenceListReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppendReferenceListReply{`,
		`}`,
	}, "")
	return s
}
func (this *RemoveReferenceListReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoveReferenceListReply{`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckReply{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepairRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepairRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepairReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepairReply{`,
		`}`,
	}, "")
	return s
}
func valueToStringDaemon(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Permission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Delete = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJWTRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJWTRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJWTRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permission == nil {
				m.Permission = &Permission{}
			}
			if err := m.Permission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJWTReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJWTReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJWTReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditPermissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditPermissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditPermissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permission == nil {
				m.Permission = &Permission{}
			}
			if err := m.Permission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditPermissionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditPermissionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditPermissionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPermissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPermissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPermissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPermissionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPermissionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPermissionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permission == nil {
				m.Permission = &Permission{}
			}
			if err := m.Permission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncrKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncrKey = append(m.EncrKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncrKey == nil {
				m.EncrKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Previous = append(m.Previous[:0], dAtA[iNdEx:postIndex]...)
			if m.Previous == nil {
				m.Previous = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next[:0], dAtA[iNdEx:postIndex]...)
			if m.Next == nil {
				m.Next = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevMeta == nil {
				m.PrevMeta = &Meta{}
			}
			if err := m.PrevMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevMeta == nil {
				m.PrevMeta = &Meta{}
			}
			if err := m.PrevMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteFileReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteFileReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteFileReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevKey = append(m.PrevKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevKey == nil {
				m.PrevKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevMeta == nil {
				m.PrevMeta = &Meta{}
			}
			if err := m.PrevMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteStreamReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteStreamReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFileReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFileReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFileReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadStreamReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadStreamReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadStreamReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromEpoch", wireType)
			}
			m.FromEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromEpoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToEpoch", wireType)
			}
			m.ToEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToEpoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalkReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalkReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalkReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReferenceListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendReferenceListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendReferenceListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveReferenceListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveReferenceListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveReferenceListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceList = append(m.ReferenceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReferenceListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendReferenceListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendReferenceListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveReferenceListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveReferenceListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveReferenceListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (CheckReply_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDaemon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDaemon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDaemon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDaemon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDaemon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("schema/daemon.proto", fileDescriptorDaemon) }

var fileDescriptorDaemon = []byte{
	// 1246 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x49, 0x6f, 0xdb, 0xc6,
	0x17, 0xd7, 0x58, 0x8b, 0xad, 0x27, 0xc9, 0x91, 0xc7, 0x1b, 0xcd, 0x04, 0x8c, 0x42, 0xf8, 0xff,
	0xaf, 0x0f, 0x8d, 0xbc, 0xa4, 0xbd, 0x14, 0x08, 0xda, 0x7a, 0xa9, 0xe1, 0xc6, 0x59, 0x40, 0x17,
	0xf5, 0x21, 0x27, 0x9a, 0x1c, 0x5b, 0xac, 0xc5, 0xa5, 0x24, 0xa5, 0x46, 0x39, 0x05, 0xed, 0x2d,
	0xa7, 0x7e, 0x81, 0xf4, 0xdc, 0x8f, 0x51, 0xa0, 0x45, 0x51, 0xf4, 0x94, 0x63, 0x8f, 0xb5, 0x7a,
	0xe9, 0x31, 0x1f, 0xa1, 0x98, 0x85, 0x14, 0x45, 0x53, 0xae, 0x10, 0x05, 0x46, 0x6f, 0x7a, 0xcb,
	0xfc, 0xde, 0xef, 0x37, 0x33, 0x7c, 0x6f, 0x6c, 0x98, 0x0f, 0x8c, 0x16, 0xb1, 0xf5, 0x75, 0x53,
	0x27, 0xb6, 0xeb, 0x34, 0x3d, 0xdf, 0x0d, 0x5d, 0x5c, 0xf4, 0x7c, 0xf7, 0x59, 0x4f, 0xbe, 0x7b,
	0x66, 0x85, 0xad, 0xce, 0x49, 0xd3, 0x70, 0xed, 0xf5, 0x33, 0xf7, 0xcc, 0x5d, 0x67, 0xd1, 0x93,
	0xce, 0x29, 0xb3, 0x98, 0xc1, 0x7e, 0xf1, 0x55, 0xaa, 0x09, 0xf0, 0x84, 0xf8, 0xb6, 0x15, 0x04,
	0x96, 0xeb, 0xe0, 0x05, 0x28, 0x7e, 0xe3, 0x5b, 0x21, 0x91, 0x50, 0x03, 0xad, 0xcd, 0x68, 0xdc,
	0xc0, 0x18, 0x0a, 0x3e, 0xd1, 0x4d, 0x69, 0x8a, 0x39, 0xd9, 0x6f, 0xbc, 0x04, 0x25, 0x93, 0xb4,
	0x49, 0x48, 0xa4, 0x3c, 0xf3, 0x0a, 0x8b, 0x22, 0xe8, 0xa6, 0x6d, 0x39, 0x52, 0x81, 0x23, 0x30,
	0x43, 0x35, 0xa0, 0xbe, 0xe3, 0x13, 0x3d, 0x24, 0x9f, 0x1f, 0x7f, 0xa1, 0x91, 0xaf, 0x3b, 0x24,
	0x08, 0xf1, 0x2d, 0x28, 0x3b, 0xba, 0x4d, 0x02, 0x4f, 0x37, 0x78, 0xbd, 0xb2, 0x36, 0x70, 0xe0,
	0x4d, 0x00, 0x2f, 0xe6, 0xc5, 0x2a, 0x57, 0xb6, 0xe6, 0x9a, 0x4c, 0x62, 0x73, 0x40, 0x58, 0x4b,
	0x24, 0xa9, 0xff, 0x87, 0xd9, 0x44, 0x11, 0xaf, 0xdd, 0xa3, 0x64, 0x42, 0xf7, 0x9c, 0x38, 0x02,
	0x9e, 0x1b, 0xea, 0x06, 0xd4, 0x1f, 0x45, 0x75, 0xc6, 0x22, 0xa3, 0xd6, 0x61, 0x36, 0xb1, 0xc2,
	0x6b, 0xf7, 0xd4, 0x17, 0x08, 0x16, 0xf7, 0x4c, 0x2b, 0x4c, 0x50, 0x19, 0x4b, 0xd6, 0x12, 0x94,
	0x3a, 0x01, 0xf1, 0x0f, 0x76, 0x99, 0xa4, 0xb2, 0x26, 0xac, 0x94, 0xdc, 0xfc, 0x38, 0x72, 0x17,
	0x61, 0x3e, 0xcd, 0x80, 0x32, 0x3b, 0x84, 0x85, 0x7d, 0xf2, 0xae, 0x78, 0xa9, 0xfb, 0x80, 0x53,
	0x68, 0x74, 0x5f, 0x87, 0xd9, 0xa2, 0x71, 0xd8, 0xee, 0x41, 0x71, 0xa7, 0xd5, 0x71, 0xce, 0xe9,
	0x65, 0x0a, 0xac, 0xe7, 0x9c, 0x42, 0x5e, 0x63, 0xbf, 0x71, 0x1d, 0xf2, 0xe7, 0xa4, 0xc7, 0x4a,
	0x57, 0x35, 0xfa, 0x93, 0xf2, 0x09, 0x5a, 0xba, 0x6f, 0x06, 0x52, 0xbe, 0x91, 0xa7, 0x7c, 0xb8,
	0xa5, 0xfe, 0x80, 0xa0, 0xf0, 0x90, 0x84, 0x3a, 0x3d, 0x5a, 0xe2, 0xb9, 0x46, 0x4b, 0xe0, 0x70,
	0x23, 0x03, 0x48, 0x82, 0x69, 0xe2, 0x18, 0xfe, 0x03, 0xd2, 0x63, 0xbb, 0x5a, 0xd5, 0x22, 0x13,
	0xaf, 0x42, 0xc9, 0xa0, 0x8c, 0x02, 0xa9, 0xd0, 0xc8, 0xaf, 0x55, 0xb6, 0xaa, 0x42, 0x00, 0xa3,
	0xa9, 0x89, 0x18, 0x96, 0x61, 0xc6, 0xf3, 0x49, 0xd7, 0x72, 0x3b, 0x81, 0x54, 0x64, 0x00, 0xb1,
	0x4d, 0xa5, 0x38, 0xe4, 0x59, 0x28, 0x95, 0x98, 0x9f, 0xfd, 0x56, 0x7f, 0x42, 0x50, 0x3d, 0xa6,
	0x5f, 0x4d, 0xb4, 0xef, 0x82, 0x12, 0x1a, 0x50, 0xba, 0x0d, 0x05, 0x9b, 0x84, 0xba, 0xb8, 0xd4,
	0x15, 0x51, 0x96, 0xaa, 0xd2, 0x58, 0x80, 0x6a, 0xeb, 0xea, 0xed, 0x0e, 0x11, 0x8c, 0xb9, 0x81,
	0x57, 0xa1, 0xe6, 0x93, 0x53, 0xe2, 0x13, 0xc7, 0x20, 0x87, 0x56, 0x10, 0x32, 0xda, 0x65, 0x6d,
	0xd8, 0x49, 0xf5, 0x52, 0x7e, 0x54, 0x6f, 0x91, 0x9d, 0x64, 0x64, 0xe2, 0xf7, 0xb8, 0x12, 0x5a,
	0x87, 0x31, 0x4e, 0x95, 0x8e, 0x83, 0xea, 0x5d, 0x00, 0xa1, 0x80, 0x9e, 0x75, 0xc4, 0x16, 0x8d,
	0x60, 0xab, 0xfe, 0x8e, 0xa0, 0xce, 0xf2, 0x3f, 0xb3, 0xda, 0x93, 0xa8, 0x96, 0x61, 0xe6, 0xd4,
	0x6a, 0x93, 0x27, 0x7a, 0xd8, 0x62, 0xc2, 0xcb, 0x5a, 0x6c, 0x5f, 0x9f, 0xf6, 0x4d, 0x98, 0x4d,
	0x68, 0x19, 0x4b, 0xff, 0xaf, 0x08, 0x30, 0x5b, 0x73, 0x14, 0xfa, 0x44, 0xb7, 0xff, 0x1b, 0xe7,
	0x5e, 0x7d, 0x0b, 0xed, 0xf7, 0xc4, 0x39, 0x46, 0x3a, 0xc6, 0x52, 0xff, 0x09, 0x54, 0x34, 0xa2,
	0x9b, 0x6f, 0xaf, 0x5a, 0xdd, 0x87, 0x32, 0x47, 0x10, 0x1d, 0x9b, 0x6f, 0x01, 0xba, 0x72, 0x0b,
	0xa6, 0x32, 0xb6, 0x40, 0xfd, 0x18, 0x6e, 0x50, 0xa0, 0xab, 0xaf, 0xe1, 0x15, 0xb7, 0x4c, 0xfd,
	0x10, 0x6a, 0x03, 0x00, 0xca, 0xe6, 0x52, 0x5d, 0x94, 0x55, 0xf7, 0x7f, 0x30, 0x47, 0x97, 0xfd,
	0xcb, 0xf1, 0xab, 0x0f, 0x39, 0xbd, 0xe4, 0xee, 0x4e, 0xa2, 0x76, 0x1b, 0x6a, 0xbb, 0x6c, 0xe4,
	0x4e, 0xb0, 0xf5, 0x35, 0xa8, 0x44, 0x18, 0x74, 0x74, 0xe8, 0x50, 0x39, 0xd6, 0xdb, 0xe7, 0x11,
	0xa0, 0x0c, 0x33, 0x41, 0xa8, 0xfb, 0xe1, 0x83, 0x18, 0x35, 0xb6, 0xe9, 0x34, 0x39, 0xf5, 0x5d,
	0x7b, 0x8f, 0xb5, 0xe0, 0x29, 0xd6, 0x82, 0x07, 0x0e, 0x7a, 0x19, 0x43, 0x97, 0xc7, 0xf2, 0x2c,
	0x16, 0x99, 0xea, 0x73, 0x28, 0xf3, 0x12, 0x54, 0xfe, 0xf5, 0x7e, 0x22, 0x6a, 0x07, 0xe4, 0x4f,
	0x3d, 0x8f, 0x38, 0xa6, 0x96, 0x74, 0x4f, 0xf0, 0xbd, 0x5e, 0x2a, 0x9b, 0x1f, 0x51, 0x56, 0x23,
	0xb6, 0xdb, 0x25, 0xd7, 0x5b, 0x56, 0x06, 0x29, 0x53, 0x2d, 0x3d, 0x68, 0x19, 0xa4, 0x4c, 0x4a,
	0x34, 0xd6, 0x80, 0xea, 0x4e, 0x8b, 0x18, 0xe7, 0xa3, 0x2f, 0xf2, 0xcf, 0x08, 0x40, 0xa4, 0xd0,
	0x53, 0xdc, 0x80, 0x52, 0x10, 0xea, 0x61, 0x27, 0x60, 0x39, 0xb3, 0x5b, 0x52, 0x3c, 0x47, 0xa3,
	0x94, 0xe6, 0x11, 0x8b, 0x6b, 0x22, 0x4f, 0xfd, 0x16, 0x41, 0x89, 0xbb, 0xf0, 0x1a, 0x4c, 0x5b,
	0x4e, 0x57, 0x6f, 0x5b, 0x66, 0x3d, 0x27, 0xdf, 0x7c, 0xf9, 0xaa, 0xb1, 0x3c, 0x58, 0xc6, 0x53,
	0x0e, 0x78, 0x18, 0xaf, 0xb2, 0x93, 0xb7, 0xcc, 0x3a, 0x92, 0x57, 0x5e, 0xbe, 0x6a, 0x2c, 0xa6,
	0xf3, 0xbe, 0x64, 0x59, 0x6b, 0x30, 0xed, 0x7a, 0xa1, 0x65, 0xeb, 0xed, 0xfa, 0x54, 0x36, 0xde,
	0x63, 0x1e, 0x56, 0xef, 0xd0, 0x8f, 0xdd, 0xd3, 0x2d, 0x7f, 0xb4, 0xd0, 0x1a, 0xed, 0x6d, 0x3c,
	0xc5, 0x6b, 0xf7, 0xb6, 0x7e, 0xc9, 0x27, 0x1e, 0x8e, 0x47, 0xc4, 0xef, 0x5a, 0x06, 0xc1, 0xf7,
	0xa1, 0x1c, 0x3f, 0x3a, 0xf1, 0x72, 0x24, 0x3d, 0xf5, 0xd6, 0x95, 0x17, 0x2f, 0x07, 0xe8, 0x5e,
	0xe7, 0xf0, 0x0e, 0xdc, 0xe0, 0xbe, 0x18, 0x38, 0x06, 0x49, 0xbf, 0x51, 0x63, 0x90, 0xd4, 0x53,
	0x94, 0x81, 0xf0, 0xcf, 0x78, 0x12, 0x90, 0x43, 0x98, 0xdd, 0xb7, 0xba, 0x24, 0xf1, 0xc7, 0xc0,
	0x2d, 0x91, 0x9a, 0xf9, 0xce, 0x95, 0xe5, 0x11, 0x51, 0x8e, 0xf6, 0x08, 0xea, 0xfc, 0x86, 0xbd,
	0x23, 0xbc, 0x03, 0xa8, 0x0d, 0xbd, 0x43, 0xf1, 0x4d, 0x91, 0x9e, 0xf5, 0xd6, 0x95, 0x57, 0xb2,
	0x83, 0x0c, 0x6a, 0xeb, 0xbb, 0x12, 0xd4, 0x1e, 0x9f, 0x7c, 0x45, 0x8c, 0x30, 0x3a, 0xc3, 0x4d,
	0x28, 0xb2, 0xc1, 0x87, 0xe7, 0xc5, 0xba, 0xe4, 0x03, 0x4e, 0x9e, 0x1b, 0x76, 0x72, 0x3e, 0xf7,
	0xa1, 0x1c, 0xbf, 0x13, 0xe2, 0xcd, 0x4e, 0xbf, 0x82, 0xe2, 0xcd, 0x1e, 0x7e, 0x52, 0xa8, 0x39,
	0xbc, 0x07, 0x95, 0xc4, 0xa8, 0xc5, 0x2b, 0xc9, 0xbc, 0xa1, 0x39, 0x22, 0x2f, 0x67, 0x85, 0x18,
	0xc8, 0x1a, 0xc2, 0x4d, 0x28, 0xd0, 0x91, 0x82, 0xb1, 0x48, 0x4a, 0x4c, 0x62, 0xb9, 0x3e, 0xe4,
	0xe3, 0x65, 0x3f, 0x82, 0x99, 0x68, 0xc0, 0xe1, 0xa5, 0x44, 0x3c, 0xc9, 0x79, 0xe1, 0x92, 0x9f,
	0xaf, 0xdd, 0x06, 0x18, 0x8c, 0x2f, 0x2c, 0x25, 0xb2, 0x86, 0x09, 0x2f, 0x65, 0x44, 0x18, 0xc2,
	0x06, 0xc2, 0x1f, 0x40, 0x69, 0x57, 0xfc, 0x99, 0x28, 0xb2, 0x86, 0x46, 0x98, 0x8c, 0x53, 0x5e,
	0x5e, 0x79, 0x03, 0x0a, 0x74, 0x66, 0xc4, 0x2a, 0x13, 0x33, 0x2a, 0x56, 0x19, 0x0f, 0x15, 0x56,
	0xe7, 0x29, 0xcc, 0x67, 0xf4, 0x3e, 0x7c, 0x47, 0x24, 0x8f, 0x9e, 0x02, 0xf2, 0xed, 0xab, 0x52,
	0x38, 0x9d, 0xa7, 0x30, 0x9f, 0xd1, 0x3c, 0x63, 0xf0, 0xd1, 0xbd, 0x3e, 0x06, 0x1f, 0xd9, 0x7b,
	0x73, 0xf4, 0x2a, 0xb2, 0x86, 0x15, 0x5f, 0xc5, 0x64, 0x2f, 0x8e, 0xaf, 0xe2, 0xa0, 0xa7, 0xa9,
	0x39, 0xba, 0xa9, 0xbc, 0x4b, 0xe1, 0xc1, 0xd1, 0x25, 0xfa, 0x9a, 0x8c, 0x53, 0x5e, 0xb6, 0x6a,
	0xfb, 0xfd, 0xd7, 0x17, 0x4a, 0xee, 0x8f, 0x0b, 0x25, 0xf7, 0xe6, 0x42, 0x41, 0x2f, 0xfa, 0x0a,
	0xfa, 0xb1, 0xaf, 0xa0, 0xdf, 0xfa, 0x0a, 0x7a, 0xdd, 0x57, 0xd0, 0x9f, 0x7d, 0x05, 0xfd, 0xdd,
	0x57, 0x72, 0x6f, 0xfa, 0x0a, 0xfa, 0xfe, 0x2f, 0x25, 0x77, 0x52, 0x62, 0xff, 0x2c, 0xb8, 0xf7,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb6, 0x0f, 0xaf, 0x76, 0x79, 0x10, 0x00, 0x00,
}
